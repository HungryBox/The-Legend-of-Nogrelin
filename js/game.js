// Generated by CoffeeScript 1.9.3
(function() {
  var Actor, Enemy, Grid, GridCodes, GridSpace, Ogre, Player, actors, bgImage, bgReady, canvas, ctx, enemyActionAvailable, floorImage, floorReady, grid, hero, keysDown, main, ogre, ogreImage, ogreReady, playerActionAvailable, playerImage, playerReady, render, requestAnimationFrame, update, w, wallImage, wallReady,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  GridCodes = {
    floor: 0,
    wall: 1,
    door: 2,
    player: "P",
    ogre: "O"
  };

  Actor = (function() {
    function Actor(x1, y1) {
      this.x = x1;
      this.y = y1;
      return;
    }

    Actor.prototype.toGridSpace = function() {};

    return Actor;

  })();

  Player = (function(superClass) {
    extend(Player, superClass);

    Player.prototype.seeRange = 2;

    function Player(name, type, x1, y1) {
      this.name = name;
      this.type = type;
      this.x = x1;
      this.y = y1;
      Player.__super__.constructor.call(this, this.x, this.y);
      return;
    }

    Player.prototype.toGridSpace = function() {
      return GridCodes.player;
    };

    Player.prototype.getName = function() {
      return this.name + " the " + this.type;
    };

    Player.prototype.getType = function() {
      return this.type;
    };

    return Player;

  })(Actor);

  Enemy = (function(superClass) {
    extend(Enemy, superClass);

    function Enemy(name, type, x1, y1) {
      this.name = name;
      this.type = type;
      this.x = x1;
      this.y = y1;
      Enemy.__super__.constructor.call(this, this.x, this.y);
      return;
    }

    Enemy.prototype.getName = function() {
      return this.name + " the " + this.type;
    };

    Enemy.prototype.getType = function() {
      return this.type;
    };

    return Enemy;

  })(Actor);

  Ogre = (function(superClass) {
    extend(Ogre, superClass);

    function Ogre(name, x1, y1) {
      this.name = name;
      this.x = x1;
      this.y = y1;
      Ogre.__super__.constructor.call(this, this.name, GridCodes.ogre, this.x, this.y);
      return;
    }

    Ogre.prototype.toGridSpace = function() {
      return GridCodes.ogre;
    };

    Ogre.prototype.getName = function() {
      return this.name + " the Ogre";
    };

    return Ogre;

  })(Enemy);

  GridSpace = (function() {
    GridSpace.prototype.size = 128;

    function GridSpace(x1, y1, object) {
      this.x = x1;
      this.y = y1;
      this.object = object;
    }

    GridSpace.prototype.setObject = function(object) {
      this.object = object;
    };

    GridSpace.prototype.getSpace = function() {
      return this.object;
    };

    return GridSpace;

  })();

  Grid = (function() {
    function Grid(maxWidth, maxHeight) {
      var x, y;
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this.grid = (function() {
        var k, ref, results;
        results = [];
        for (x = k = 0, ref = this.maxWidth; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {
          results.push((function() {
            var l, ref1, results1;
            results1 = [];
            for (y = l = 0, ref1 = this.maxHeight; 0 <= ref1 ? l < ref1 : l > ref1; y = 0 <= ref1 ? ++l : --l) {
              results1.push(new GridSpace(x, y, GridCodes.wall));
            }
            return results1;
          }).call(this));
        }
        return results;
      }).call(this);
      return;
    }

    Grid.prototype.getGridSpace = function(x, y) {
      return this.grid[x][y].getSpace();
    };

    Grid.prototype.emptyGrid = function() {
      var k, l, ref, ref1, x, y;
      for (x = k = 1, ref = this.maxWidth - 1; 1 <= ref ? k < ref : k > ref; x = 1 <= ref ? ++k : --k) {
        for (y = l = 1, ref1 = this.maxHeight - 1; 1 <= ref1 ? l < ref1 : l > ref1; y = 1 <= ref1 ? ++l : --l) {
          this.grid[x][y].setObject(GridCodes.floor);
        }
      }
    };

    Grid.prototype.populateGrid = function(actors) {
      var actor, k, len;
      this.emptyGrid();
      for (k = 0, len = actors.length; k < len; k++) {
        actor = actors[k];
        this.grid[actor.x][actor.y].setObject(actor.toGridSpace());
      }
    };

    Grid.prototype.draw = function(x, y, xmin, ymin) {
      var i, j;
      i = (x - xmin) * this.grid[0][0].size;
      j = (y - ymin) * this.grid[0][0].size;
      if (bgReady) {
        ctx.drawImage(bgImage, i, j);
      }
      if (x >= 0 && y >= 0 && x < this.maxWidth && y < this.maxHeight) {
        if (floorReady) {
          ctx.drawImage(floorImage, i, j);
        }
        switch (this.grid[x][y].getSpace()) {
          case GridCodes.ogre:
            if (ogreReady) {
              ctx.drawImage(ogreImage, i, j);
            }
            break;
          case GridCodes.wall:
            if (wallReady) {
              ctx.drawImage(wallImage, i, j);
            }
            break;
          case GridCodes.player:
            if (playerReady) {
              ctx.drawImage(playerImage, i, j);
            }
        }
      }
    };

    return Grid;

  })();

  hero = new Player("Nogrelin", "Death Knight", 1, 1);

  ogre = new Ogre("Ogrelin", 2, 2);

  grid = new Grid(7, 7);

  actors = [hero, ogre];

  canvas = document.createElement("canvas");

  ctx = canvas.getContext("2d");

  canvas.width = (hero.seeRange * 2 + 1) * 128;

  canvas.height = (hero.seeRange * 2 + 1) * 128;

  document.body.appendChild(canvas);

  bgReady = false;

  bgImage = new Image();

  bgImage.onload = function() {
    bgReady = true;
  };

  bgImage.src = "images/Background.png";

  floorReady = false;

  floorImage = new Image();

  floorImage.onload = function() {
    floorReady = true;
  };

  floorImage.src = "images/Floor.png";

  wallReady = false;

  wallImage = new Image();

  wallImage.onload = function() {
    wallReady = true;
  };

  wallImage.src = "images/Wall.png";

  playerReady = false;

  playerImage = new Image();

  playerImage.onload = function() {
    playerReady = true;
  };

  playerImage.src = "images/Nogrelin.png";

  ogreReady = false;

  ogreImage = new Image();

  ogreImage.onload = function() {
    ogreReady = true;
  };

  ogreImage.src = "images/Ogre.png";

  keysDown = {};

  playerActionAvailable = true;

  enemyActionAvailable = true;

  addEventListener("keydown", function(e) {
    keysDown[e.keyCode] = true;
  }, false);

  addEventListener("keyup", function(e) {
    playerActionAvailable = true;
    enemyActionAvailable = true;
    delete keysDown[e.keyCode];
  }, false);

  update = function() {
    var num;
    if (38 in keysDown && playerActionAvailable) {
      if (grid.getGridSpace(hero.x, hero.y - 1) === GridCodes.floor) {
        hero.y -= 1;
      }
      playerActionAvailable = false;
    }
    if (40 in keysDown && playerActionAvailable) {
      if (grid.getGridSpace(hero.x, hero.y + 1) === GridCodes.floor) {
        hero.y += 1;
      }
      playerActionAvailable = false;
    }
    if (37 in keysDown && playerActionAvailable) {
      if (grid.getGridSpace(hero.x - 1, hero.y) === GridCodes.floor) {
        hero.x -= 1;
      }
      playerActionAvailable = false;
    }
    if (39 in keysDown && playerActionAvailable) {
      if (grid.getGridSpace(hero.x + 1, hero.y) === GridCodes.floor) {
        hero.x += 1;
        playerActionAvailable = false;
      }
    }
    if (enemyActionAvailable) {
      num = Math.floor(Math.random() * 4 + 1);
      switch (num) {
        case 1:
          if (grid.getGridSpace(ogre.x, ogre.y - 1) === GridCodes.floor) {
            ogre.y -= 1;
          } else if (grid.getGridSpace(ogre.x, ogre.y - 1) === GridCodes.player) {
            console.log((ogre.getName()) + " attacked " + (hero.getName()));
          }
          enemyActionAvailable = false;
          break;
        case 2:
          if (grid.getGridSpace(ogre.x, ogre.y + 1) === GridCodes.floor) {
            ogre.y += 1;
          } else if (grid.getGridSpace(ogre.x, ogre.y + 1) === GridCodes.player) {
            console.log((ogre.getName()) + " attacked " + (hero.getName()));
          }
          enemyActionAvailable = false;
          break;
        case 3:
          if (grid.getGridSpace(ogre.x - 1, ogre.y) === GridCodes.floor) {
            ogre.x -= 1;
          } else if (grid.getGridSpace(ogre.x - 1, ogre.y) === GridCodes.player) {
            console.log((ogre.getName()) + " attacked " + (hero.getName()));
          }
          enemyActionAvailable = false;
          break;
        case 4:
          if (grid.getGridSpace(ogre.x + 1, ogre.y) === GridCodes.floor) {
            ogre.x += 1;
          } else if (grid.getGridSpace(ogre.x + 1, ogre.y) === GridCodes.player) {
            console.log((ogre.getName()) + " attacked " + (hero.getName()));
          }
          enemyActionAvailable = false;
      }
    }
  };

  render = function() {
    var i, j, k, l, ref, ref1, ref2, ref3;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    grid.emptyGrid();
    grid.populateGrid(actors);
    for (i = k = ref = hero.x - hero.seeRange, ref1 = hero.x + hero.seeRange; ref <= ref1 ? k <= ref1 : k >= ref1; i = ref <= ref1 ? ++k : --k) {
      for (j = l = ref2 = hero.y - hero.seeRange, ref3 = hero.y + hero.seeRange; ref2 <= ref3 ? l <= ref3 : l >= ref3; j = ref2 <= ref3 ? ++l : --l) {
        grid.draw(i, j, hero.x - hero.seeRange, hero.y - hero.seeRange);
      }
    }
  };

  main = function() {
    var delta, now;
    now = Date.now();
    delta = now - previousTime;
    update(delta / 1000);
    render();
    this.previousTime = now;
    requestAnimationFrame(main);
  };

  w = window;

  requestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;

  this.previousTime = Date.now();

  main();

}).call(this);
